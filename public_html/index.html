<!DOCTYPE html>

<html>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
    
    <head>
        <title>TTT</title>
        <style>
            td {
                width: 30px;
                height: 30px;
                border: gray solid 1px;
                margin: 0px;
                padding: 0px;
                text-align: center;
                font-size: 1.5em;
            }
            table { border-collapse: collapse; }            
            
        </style>
        
        <script>
            
            $(function() { 
                $('td').on('click', onCellClick);
            });
            
            var signX = "X";
            var signO = "O";
            var currentPlayer = signX;
           
            function switchPlayer() {
                currentPlayer = (currentPlayer === signX) ? signO : signX;
            }
          
            // returns x if x wins, o if o wins
            function checkWinner(grid) {
                var xCounter = 0;
                var oCounter = 0;
                
                // check each column
                for (var x = 0; x < 3; x++) {
                    oCounter = 0;
                    xCounter = 0;
                    for (var y = 0; y < 3; y++) {
                        if (grid[x][y] === 2) {
                            oCounter++;
                        }
                        else if (grid[x][y] === 1){
                            xCounter++;
                        }
                    }
                    if (xCounter === 3) {
                        return 'x';
                    }
                    if (oCounter === 3) {
                        return 'o';
                    }
                }
                
                // check each row
                for (var y = 0; y < 3; y++) {
                    oCounter = 0;
                    xCounter = 0;
                    for (var x = 0; x < 3; x++) {
                        if (grid[x][y] === 2) {
                            oCounter++;
                        }
                        else if (grid[x][y] === 1){
                            xCounter++;
                        }
                    }
                    if (xCounter === 3) {
                        return 'x';
                    }
                    if (oCounter === 3) {
                        return 'o';
                    }
                }
                
                //check diagonals
                oCounter = 0;
                xCounter = 0;
                for (var y = 0, x = 0; y < 3; y++, x++) {
                        if (grid[x][y] === 2) {
                            oCounter++;
                        }
                        else if (grid[x][y] === 1){
                            xCounter++;
                        }
                }
                if (xCounter === 3) {
                    return 'x';
                }
                if (oCounter === 3) {
                    return 'o';
                }
                
                oCounter = 0;
                xCounter = 0;
                for (var y = 2, x = 0; x < 3; y--, x++) {
                        if (grid[x][y] === 2) {
                            oCounter++;
                        }
                        else if (grid[x][y] === 1){
                            xCounter++;
                        }
                }
                if (xCounter === 3) {
                    return 'x';
                }
                if (oCounter === 3) {
                    return 'o';
                }
                
                return null;
            }
            
            
            // done as Immediately Invoked Function Expression (IIFE) to hide private members 
            (function () {

                // create public object and expose a method that returns an instance 
                window.$TTTGrid = { create: function () { return new TTTGrid(); } }; // anonymous object 

                // constructor
                function TTTGrid() {
                    this.grid = []; // store coordinates
                    // grid[y][x]
                    // 1 - x, 2 - o, 0 - none
                    // initialize grid to all zeroes
                    for (var i = 0; i < 3; i++) {
                        this.grid[i] = [0,0,0];
                    }

                    this.displayGrid = displayGrid;
                    this.markState = markState;
                    this.countZeroesInGrid = countZerosInGrid;
                }

                function markState(x, y, state) {
                    this.grid[y][x] = state;
                    //this.displayGrid();
                }

                
                function countZerosInGrid() {
                    var counter = 0;
                    
                    for (var y = 0; y < 3; y++) {
                        for (var x = 0; x < 3; x++) {
                            if (this.grid[y][x] === 0) counter++;
                        }
                    }
                    
                    return counter;
                }

                function displayGrid(grid) {
                    var g = (grid === undefined) ? this.grid : grid;
                   
                    for (var y = 0; y < 3; y++) {
                        document.write('<br>');
                        for (var x = 0; x < 3; x++) {
                            document.write(g[y][x] + ' ');
                        }
                    }
                }

            }());

            var tttGrid = window.$TTTGrid.create();
            var gameOver = 0;
            var nodesExpanded = 0;
            //tttGrid.displayGrid();
            //alert(Math.min.apply(Math, [3, 1, 5]));

            function checkResult() {
                    var result = checkWinner(tttGrid.grid);
                    if (result != null) {
                        gameOver = 1;
                        alert(result + ' won!');
                        return true;
                    }
                    if (tttGrid.countZeroesInGrid() === 0) {
                        gameOver = 1;
                        alert('Draw!');
                        return true;
                    }
                return false;    
            }

            function onCellClick() {
                
                if (gameOver === 1) return;
                //alert($(this).text());
                
                if ($(this).text() === '') {
                    $(this).html(currentPlayer);

                    var state = -1;
                    if (currentPlayer === signX) {
                        state = 1;
                    }
                    else {
                        state = 2; 
                    }
                    tttGrid.markState(this.id.substring(1,2), this.id.substring(0,1), state);                     
                    if (checkResult()) return;
                    switchPlayer();

                    // computor's turn
                    state = (state === 2) ? 1: 2; // flip the state, because the computer runs a different state
                    nodesExpanded = 0;
                    var recommendedMove  = minimax({value: 0, x: parseInt(this.id.substring(1,2)), y: parseInt(this.id.substring(0,1)), grid: tttGrid.grid}, state);
                    $('#message').html('Nodes expanded: ' + nodesExpanded);
                    
                    
                    if ($('#' + recommendedMove.y + recommendedMove.x).text() === '') {
                        $('#' + recommendedMove.y + recommendedMove.x).html(currentPlayer);
                        tttGrid.markState(recommendedMove.x, recommendedMove.y, state);                     
                        if (checkResult()) return;
                        switchPlayer();
                    }
                    else {
                        alert('Violation: cell(x,y) (' + recommendedMove.x + ',' + recommendedMove.y + ') is occupied');
                    }
                }
                //alert(this.id);
            }

    
            // node { value: <1|-1|0>, x: <x>, y: <y>, grid: TTTGrid }
            function minimax(node, maximizing) {
                
                if (maximizing != 2 && maximizing != 1) { alert('maximizing is wrong!'); return null; }
                
                nodesExpanded++;
                // just in case
                if (nodesExpanded >= 100000) {
                    // it gets here, so, its bad
                    alert('nodesExpanded >= 100000');
                    return null;
                }
                
                // node { value: <1|-1|0>, x: <x>, y: <y> }
                // if terminal state (win or draw), return node
                // first check if current type (x or o) won
                var result = checkWinner(node.grid);
                
                // this means someone won (virtually during the mapping state)
                if ( result !== null) {
                    if (result === 'x') { // if x won
                        node.value = (maximizing === 2) ? 1 : -1;
                    } 
                    else if (result === 'o') { // if o won
                        node.value = (maximizing === 2) ? -1 : 1;
                    }
                    return node;
                }

                var successors = getSuccessors(node);
                //document.write('<br>' + successors.length);
                // then check if the grid is filled
                if (successors.length === 0) {
                    // grid filled and no winner if got to this point
                    node.value = 0;
                    return node;
                }
                
                var bestValue = 0;
                var tempNode = node;
 
                if (maximizing === 1) {
                    bestValue = -2;
                    for (var i = 0; i < successors.length; i++) {
                        var successorNode = successors[i];
                        // copy grid from a successor
                        var grid = jQuery.extend(true, {}, successorNode.grid);
                        
                        if (node.x === successorNode.x && node.y === successorNode.y) {
                            alert('Violation!!!: x:' + node.x + ' y:' + node.y);
                            tttGrid.displayGrid(node.grid);
                            return;
                        }
                        
                        grid[successorNode.y][successorNode.x] = 2; // 2 for o
                        // update grid in a successor
                        successorNode.grid = grid;
                        var n = minimax(successorNode, 2);
                        if (n.value > bestValue) {
                            bestValue = n.value;
                            tempNode = n;
                        }
                    }
                }
                else { // if maximizing === 2 
                    bestValue = 2;
                    for (var i = 0; i < successors.length; i++) {
                        var successorNode = successors[i];
                        // copy grid from a successor
                        var grid = jQuery.extend(true, {}, successorNode.grid);
                        
                        if (node.x === successorNode.x && node.y === successorNode.y) {
                            alert('Violation!!!: x:' + node.x + ' y:' + node.y);
                            tttGrid.displayGrid(node.grid);
                            return;
                        }
                        
                        grid[successorNode.y][successorNode.x] = 1; // 1 for x
                        // update grid in a successor
                        successorNode.grid = grid;
                        var n = minimax(successorNode, 1);
                        if (n.value < bestValue) {
                            bestValue = n.value;
                            tempNode = n;
                        }
                    }
                }
                
                return tempNode;
            }
            
            // returns an array of possible successors
            function getSuccessors(node) {
                var successors = [];
                
                for (var y = 0; y < 3; y++) {
                    for (var x = 0; x < 3; x++) {
                        if (node.grid[y][x] === 0) { // if space is not taken by either x or o
                            successors.push({value: 0, x: x, y: y, grid: node.grid});
                        }
                    }
                }
                
                return successors;
            }
    
        </script>
        
        
    </head>
    <body>
        <div>
            
            <div id="message"></div>
            <table>
                <tr>
                    <td id='00'></td>
                    <td id='01'></td>
                    <td id='02'></td>
                </tr>
                <tr>
                    <td id='10'></td>
                    <td id='11'></td>
                    <td id='12'></td>
                </tr>
                <tr>
                    <td id='20'></td>
                    <td id='21'></td>
                    <td id='22'></td>
                </tr>
            </table>
        </div>
    </body>
</html>
